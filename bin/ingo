#!/usr/bin/env bash

set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# shellcheck source=../lib/env.sh
# shellcheck disable=SC1091
source "$ROOT_DIR/lib/env.sh"
# shellcheck source=../lib/fetch.sh
# shellcheck disable=SC1091
source "$ROOT_DIR/lib/fetch.sh"
# shellcheck source=../lib/http.sh
# shellcheck disable=SC1091
source "$ROOT_DIR/lib/http.sh"
# shellcheck source=../lib/ocr.sh
# shellcheck disable=SC1091
source "$ROOT_DIR/lib/ocr.sh"
# shellcheck source=../lib/chunk.sh
# shellcheck disable=SC1091
source "$ROOT_DIR/lib/chunk.sh"
# shellcheck source=../lib/embed.sh
# shellcheck disable=SC1091
source "$ROOT_DIR/lib/embed.sh"
# shellcheck source=../lib/relevance.sh
# shellcheck disable=SC1091
source "$ROOT_DIR/lib/relevance.sh"
# shellcheck source=../lib/query.sh
# shellcheck disable=SC1091
source "$ROOT_DIR/lib/query.sh"

usage() {
  cat <<'EOF'
ingo - shell runtime for Upstash Vector (ingest + query)

Usage:
  ingo doctor
  ingo fetch [--url URL] [--dir DIR]
  ingo ocr [--dir DIR]
  ingo chunk [--strict|--no-strict]
  ingo embed [--force]
  ingo cleanup [--markers]
  ingo run [--url URL] [--dir DIR] [--strict|--no-strict] [--force]
  ingo query "<pregunta>" [--top-k N]
EOF
}

doctor() {
  ingo_load_env
  ingo_require_positive_integer "INGO_HTTP_CONNECT_TIMEOUT" "$INGO_HTTP_CONNECT_TIMEOUT"
  ingo_require_positive_integer "INGO_HTTP_READ_TIMEOUT" "$INGO_HTTP_READ_TIMEOUT"
  ingo_require_nonnegative_integer "INGO_HTTP_RETRY_ATTEMPTS" "$INGO_HTTP_RETRY_ATTEMPTS"
  ingo_require_positive_integer "INGO_HTTP_RETRY_BACKOFF_MIN" "$INGO_HTTP_RETRY_BACKOFF_MIN"
  ingo_require_positive_integer "INGO_HTTP_RETRY_BACKOFF_MAX" "$INGO_HTTP_RETRY_BACKOFF_MAX"
  ingo_require_positive_integer "INGO_HTTP_RETRY_BACKOFF_FACTOR" "$INGO_HTTP_RETRY_BACKOFF_FACTOR"
  ingo_require_nonnegative_integer "INGO_HTTP_RETRY_AFTER_MAX" "$INGO_HTTP_RETRY_AFTER_MAX"
  ingo_require_bin curl
  ingo_require_bin jq
  ingo_require_env
  if [ "$INGO_ROLE" != "query" ]; then
    ingo_require_bin tesseract
    ingo_require_bin awk
    ingo_require_bin grep
    ingo_require_bin pdftotext
    ingo_require_bin pdftoppm
    ingo_require_tesseract_lang "$INGO_LANG"
  fi
  printf "http: connect_timeout=%s read_timeout=%s retry_attempts=%s backoff_min=%s backoff_max=%s backoff_factor=%s retry_after_max=%s\n" \
    "$INGO_HTTP_CONNECT_TIMEOUT" \
    "$INGO_HTTP_READ_TIMEOUT" \
    "$INGO_HTTP_RETRY_ATTEMPTS" \
    "$INGO_HTTP_RETRY_BACKOFF_MIN" \
    "$INGO_HTTP_RETRY_BACKOFF_MAX" \
    "$INGO_HTTP_RETRY_BACKOFF_FACTOR" \
    "$INGO_HTTP_RETRY_AFTER_MAX"
  echo "ok"
}

cmd_fetch() {
  ingo_load_env
  ingo_require_ingest_enabled
  ingo_require_bin curl

  local url=""
  local dir=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --url)
        [ "$#" -ge 2 ] || { echo "missing value for --url" >&2; return 2; }
        url="$2"
        shift 2
        ;;
      --dir)
        [ "$#" -ge 2 ] || { echo "missing value for --dir" >&2; return 2; }
        dir="$2"
        shift 2
        ;;
      *)
        echo "unknown option: $1" >&2
        return 2
        ;;
    esac
  done

  if [ -n "$dir" ]; then
    INGO_INBOX="$dir"
  fi
  ingo_prepare_dirs

  if [ -n "$url" ]; then
    local file
    file="$(ingo_fetch_url "$url" "$INGO_INBOX")"
    echo "fetched: $file"
  fi

  ingo_list_pdfs "$INGO_INBOX"
}

cmd_ocr() {
  ingo_load_env
  ingo_require_ingest_enabled
  ingo_prepare_dirs
  ingo_require_bin tesseract
  ingo_require_bin pdftotext
  ingo_require_bin pdftoppm
  local dir=""

  while [ "$#" -gt 0 ]; do
    case "$1" in
      --dir)
        [ "$#" -ge 2 ] || { echo "missing value for --dir" >&2; return 2; }
        dir="$2"
        shift 2
        ;;
      *)
        echo "unknown option: $1" >&2
        return 2
        ;;
    esac
  done

  if [ -n "$dir" ]; then
    INGO_INBOX="$dir"
  fi

  local pdf txt pdfs
  pdfs="$(ingo_list_pdfs "$INGO_INBOX")"
  if [ -z "$pdfs" ]; then
    echo "no PDFs found in INGO_INBOX=$INGO_INBOX" >&2
    return 2
  fi

  while IFS= read -r pdf; do
    [ -n "$pdf" ] || continue
    if ! txt="$(ingo_ocr_pdf "$pdf" "$ROOT_DIR/$INGO_RAW_DIR" "$INGO_LANG" "$ROOT_DIR")"; then
      echo "ocr failed: $pdf" >&2
      return 5
    fi
    echo "ocr: $pdf -> $txt"
  done <<< "$pdfs"
}

cmd_chunk() {
  ingo_load_env
  ingo_require_ingest_enabled
  ingo_prepare_dirs
  ingo_require_bin awk
  ingo_require_bin grep

  local strict="$INGO_RELEVANCE_MODE"
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --strict)
        strict="strict"
        shift
        ;;
      --no-strict)
        strict="off"
        shift
        ;;
      *)
        echo "unknown option: $1" >&2
        return 2
        ;;
    esac
  done

  local txt base out rejected
  find "$ROOT_DIR/$INGO_RAW_DIR" -maxdepth 1 -type f -name '*.txt' | sort | while IFS= read -r txt; do
    if [ ! -s "$txt" ]; then
      rejected="$ROOT_DIR/$INGO_REJECTED_DIR/$(basename "$txt")"
      mv "$txt" "$rejected"
      echo "rejected-empty: $txt -> $rejected"
      continue
    fi
    base="$(basename "$txt" .txt)"
    out="$ROOT_DIR/$INGO_CHUNK_DIR/$base.jsonl"
    if [ -s "$out" ]; then
      echo "chunk-skip: $txt -> $out"
      continue
    fi
    if [ "$strict" = "strict" ] && ! ingo_is_relevant "$txt" "$INGO_MIN_TERM_MATCHES" "$INGO_RELEVANCE_TERMS"; then
      rejected="$ROOT_DIR/$INGO_REJECTED_DIR/$(basename "$txt")"
      mv "$txt" "$rejected"
      echo "rejected: $txt -> $rejected"
      continue
    fi

    ingo_chunk_txt "$txt" "$out" "$INGO_CHUNK_SIZE" "$INGO_CHUNK_OVERLAP"
    echo "chunk: $txt -> $out"
  done
}

cmd_embed() {
  ingo_load_env
  ingo_require_ingest_enabled
  ingo_prepare_dirs
  ingo_require_bin curl
  ingo_require_bin jq
  ingo_require_env

  local force=0
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --force)
        force=1
        shift
        ;;
      *)
        echo "unknown option: $1" >&2
        return 2
        ;;
    esac
  done

  local jsonl count marker chunk_hash marker_hash marker_namespace
  find "$ROOT_DIR/$INGO_CHUNK_DIR" -maxdepth 1 -type f -name '*.jsonl' | sort | while IFS= read -r jsonl; do
    marker="${jsonl}.embedded"
    chunk_hash="$(ingo_file_sha256 "$jsonl")"
    marker_hash="$(ingo_marker_get_value "$marker" "chunk_hash")"
    marker_namespace="$(ingo_marker_get_value "$marker" "namespace")"

    if [ "$force" -ne 1 ] && [ -n "$chunk_hash" ] && [ "$marker_hash" = "$chunk_hash" ] && [ "$marker_namespace" = "$INGO_NAMESPACE" ]; then
      echo "embed-skip: $jsonl"
      continue
    fi

    count="$(ingo_embed_jsonl "$jsonl" "$INGO_NAMESPACE" "$ROOT_DIR/$INGO_RAW_DIR")"
    ingo_write_embed_marker "$marker" "$chunk_hash" "$INGO_NAMESPACE" "$count"
    echo "embed: $jsonl -> $count vectors"
  done
}

cmd_cleanup() {
  ingo_load_env
  ingo_require_ingest_enabled
  local cleanup_markers=0

  while [ "$#" -gt 0 ]; do
    case "$1" in
      --markers)
        cleanup_markers=1
        shift
        ;;
      *)
        echo "unknown option: $1" >&2
        return 2
        ;;
    esac
  done

  if [ "$INGO_CLEANUP_TEXT" = "1" ]; then
    find "$ROOT_DIR/$INGO_RAW_DIR" -maxdepth 1 -type f -name '*.txt' -delete
    find "$ROOT_DIR/$INGO_CHUNK_DIR" -maxdepth 1 -type f -name '*.jsonl' -delete
    if [ "$cleanup_markers" -eq 1 ]; then
      find "$ROOT_DIR/$INGO_CHUNK_DIR" -maxdepth 1 -type f -name '*.jsonl.embedded' -delete
      echo "cleanup: removed OCR, chunk intermediates, and embed markers"
      return 0
    fi
    echo "cleanup: removed OCR and chunk intermediates"
  else
    echo "cleanup skipped: INGO_CLEANUP_TEXT=$INGO_CLEANUP_TEXT"
  fi
}

cmd_run() {
  ingo_load_env
  ingo_require_ingest_enabled

  local url=""
  local dir=""
  local strict_flag=""
  local force=0

  while [ "$#" -gt 0 ]; do
    case "$1" in
      --url)
        [ "$#" -ge 2 ] || { echo "missing value for --url" >&2; return 2; }
        url="$2"
        shift 2
        ;;
      --dir)
        [ "$#" -ge 2 ] || { echo "missing value for --dir" >&2; return 2; }
        dir="$2"
        shift 2
        ;;
      --strict|--no-strict)
        strict_flag="$1"
        shift
        ;;
      --force)
        force=1
        shift
        ;;
      *)
        echo "unknown option: $1" >&2
        return 2
        ;;
    esac
  done

  if [ -n "$url" ] && [ -n "$dir" ]; then
    cmd_fetch --url "$url" --dir "$dir"
  elif [ -n "$url" ]; then
    cmd_fetch --url "$url"
  elif [ -n "$dir" ]; then
    cmd_fetch --dir "$dir"
  else
    cmd_fetch
  fi

  if [ -n "$dir" ]; then
    cmd_ocr --dir "$dir"
  else
    cmd_ocr
  fi

  if [ -n "$strict_flag" ]; then
    cmd_chunk "$strict_flag"
  else
    cmd_chunk
  fi
  if [ "$force" -eq 1 ]; then
    cmd_embed --force
  else
    cmd_embed
  fi
  cmd_cleanup
}

ingo_marker_get_value() {
  local marker_file="$1"
  local key="$2"
  [ -s "$marker_file" ] || return 0
  awk -F '=' -v key="$key" '$1 == key {print substr($0, index($0, "=") + 1); exit}' "$marker_file" 2>/dev/null || true
}

ingo_write_embed_marker() {
  local marker_file="$1"
  local chunk_hash="$2"
  local namespace="$3"
  local count="$4"
  {
    printf "version=2\n"
    printf "chunk_hash=%s\n" "$chunk_hash"
    printf "namespace=%s\n" "$namespace"
    printf "count=%s\n" "$count"
  } > "$marker_file"
}

cmd_query() {
  if [ "${1:-}" = "--help" ] || [ "${1:-}" = "-h" ]; then
    echo "usage: ingo query \"<pregunta>\" [--top-k N]"
    return 0
  fi

  ingo_load_env
  ingo_require_bin curl
  ingo_require_bin jq
  ingo_require_env

  local question="${1:-}"
  shift || true
  if [ -z "$question" ]; then
    echo "missing question" >&2
    return 2
  fi

  local top_k=8
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --top-k)
        [ "$#" -ge 2 ] || { echo "missing value for --top-k" >&2; return 2; }
        top_k="$2"
        shift 2
        ;;
      *)
        echo "unknown option: $1" >&2
        return 2
        ;;
    esac
  done

  case "$top_k" in
    ''|*[!0-9]*|0)
      echo "invalid --top-k: must be a positive integer" >&2
      return 2
      ;;
  esac

  ingo_query_text "$question" "$top_k" "$INGO_NAMESPACE"
}

main() {
  local cmd="${1:-}"
  case "$cmd" in
    doctor)
      shift
      doctor "$@"
      ;;
    fetch)
      shift
      cmd_fetch "$@"
      ;;
    ocr)
      shift
      cmd_ocr "$@"
      ;;
    chunk)
      shift
      cmd_chunk "$@"
      ;;
    embed)
      shift
      cmd_embed "$@"
      ;;
    cleanup)
      shift
      cmd_cleanup "$@"
      ;;
    run)
      shift
      cmd_run "$@"
      ;;
    query)
      shift
      cmd_query "$@"
      ;;
    ""|-h|--help|help)
      usage
      ;;
    *)
      echo "unknown command: $cmd" >&2
      usage >&2
      return 2
      ;;
  esac
}

main "$@"
